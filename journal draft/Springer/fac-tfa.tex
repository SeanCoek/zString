\NeedsTeXFormat{LaTeX2e}

% The following saves the original definitions of \geq and \leq (guide only).
\let\realgeq\geq
\let\realleq\leq

\documentclass{fac}

\ifprodtf \else \usepackage{latexsym}\fi

% The following macros automatically define symbols to be used in Table 1 of
% the authors' guide, using characters from the AMS symbol font MSAM.

\newcommand\black{\ensuremath{\blacktriangleright}}
\newcommand\white{\ensuremath{\vartriangleright}}

\newif\ifamsfontsloaded
\ifprodtf
  \newcommand\whbl{\white\kern-.1em--\kern-.1em\black}
  \newcommand\blwh{\black\kern-.1em--\kern-.1em\white}
  \newcommand\blbl{\black\kern-.1em--\kern-.1em\black}
  \newcommand\whwh{\white\kern-.1em--\kern-.1em\white}
  \amsfontsloadedtrue
\else
  \checkfont{msam10}
  \iffontfound
    \IfFileExists{amssymb.sty}
      {\usepackage{amssymb}\amsfontsloadedtrue
       \newcommand\whbl{\white\kern-.125em--\kern-.125em\black}%
       \newcommand\blwh{\black\kern-.125em--\kern-.125em\white}%
       \newcommand\blbl{\black\kern-.125em--\kern-.125em\black}%
       \newcommand\whwh{\white\kern-.125em--\kern-.125em\white}}
      {}
  \fi
\fi

%% Macros for the guide only %%
\newcommand\eg{\textit{e.g.\ }}
\newcommand\etc{\textit{etc}}
\newcommand\hatp{\skew3\hat{p}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}
\providecommand\AMSLaTeX{AMS\,\LaTeX}
%% End of macros for the guide %%

\newtheorem{theorem}{Theorem}[section]

\title{A Relational Static Semantics for\\
		Call Graph Construction}

\author[Xilong Zhuo and Chenyi Zhang]
    {Xilong Zhuo$^1$ and Chenyi Zhang$^2$\\
     $^1$College of Information Science and Technology, Jinan University, China\\
     $^2$College of Information Science and Technology, Jinan University, China}

\correspond{Chenyi Zhang.
            e-mail: chenyi\_zhang@jnu.edu.cn}

%\pubyear{2000}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}

\newcommand{\less}{\sqsubseteq}
\newcommand{\tflow}{\dashrightarrow}
\newcommand{\hflow}{\longrightarrow}
\newcommand{\lhflow}[1]{\stackrel{#1}{\hflow}}

\usepackage{listings}
\usepackage{amsfonts}

\begin{document}
\label{firstpage}

\makecorrespond

\maketitle

\begin{abstract}
The problem of resolving virtual method and interface calls in object-oriented languages has been a long standing challenge to the program analysis community. The complexities are due to various reasons, such as increased levels of class inheritance and polymorphism in large programs. In this paper, we propose a new approach called type flow analysis that represent propagation of type information between program variables by a group of relations without the help of a heap abstraction. We prove that regarding the precision on reachability of class information to a variable, our method produces results equivalent to that one can derive from a points-to analysis. Moreover, in practice, our method consumes lower time and space usage, as supported by the experimental results.
\end{abstract}

\begin{keywords}
Type Analysis; Static Analysis; Method Resolving; Call Graph
\end{keywords}

\section{Introduction}

For object-oriented programming languages, virtual methods (or functions) are those declared in a base class but are meant to be overridden in different child classes. Statically determine a set of methods that may be invoked at a call site is important to program optimization...
\section{Type Flow Analysis}\label{sec:type-flow-analysis}
We define a core calculus consisting of most of the key object-oriented language features...
\subsection{c$\tflow$ y}
\subsection{x$\less$ y}
\subsection{x$\lhflow{f}$ y}

\section{Implementation}\label{sec:implementation}
The analysis algorithm is written in Java, and is implemented in the Soot framework...

\subsection{Static Analysis Tool}\label{subsec:static-analysis-tool}

\subsection{Dynamic Profiler}\label{subsec:dynamic-profiler}
Since the benchmarks do not provide the run-time type of method receiver, we implement a dynamic profiling tool to record  types which a receiver can access at run-time. To achieve this, we instrument statements into the target benchmark. After this instrumentation, the run-time type will be extracted during the benchmark execution. We consider this output as groundtruth and compare it with our static result in section ~\ref{subsec:precision}. There are four manners to instrument the source code to record the run-time type of a method receiver.
\subsubsection{Insert First}\label{subsubsec:insert-first}
In this manner, the type-recorded statements will be insert before the first statement of a method block and the type of ``this'' reference in that method will be recorded. The reason we only have to record ``this'' reference is that a receiver is always passed into ``this'' reference in a method, except for static methods. 
\subsubsection{Insert Before}\label{subsubsec:insert-before}
Statements will be inserted before invocations and the type of receiver will be recorded in this manner. It is more straightforward than the method we discuss about recording ``this'' reference.
\subsubsection{Insert Last}\label{subsubsec:insert-last}
This manner is similar with ``Insert First'', except that statements are inserted after the last statement of a method block. We also record ``this'' reference in this way.
\subsubsection{Insert After}\label{subsubsec:insert-after}
Statments will be inserted right after invocations and the type of receiver will be recorded. It is similar with ``Insert Before'', except that statements are inserted at different position. We use this manner in our implementation and the reason will be discuss in section ~\ref{subsubsec:instrument}
\subsubsection{Our Instrumentation Manner}\label{subsubsec:instrument}
We use ``Insert After'' as our instrumentation manner. The reason is mainly due to the Java specification of constructor that the first statement in constructor should be either another constructor of its own or its super class. Therefore, we will get JVM voilation error if we instrument a statement before the first statement in construtor. We illustrate this example on ~\ref{fig:spec-constructor}. So both ``Insert First'' and ``Insert Before'' manners can not be applied under this circumstance. We choose ``Insert After'' over ``Insert Last'' for reason that it's more straightforward. The code before and after instrumentation are shown in \ref{fig:before-instru} and \ref{fig:after-instru}, respectively.

\begin{figure}
\begin{lstlisting}[language={java},frame={single}]
class A {
  public A() {
    //insert statements here will violate JVM specification
    super();	//invoke super class constructor
  }
  public A(int i) {
    //insert statements here will violate JVM specification
    this();    //inovke another constructor of its own
  }
}
\end{lstlisting}
\caption{Java specification on constructor}
\label{fig:spec-constructor}
\end{figure}

\begin{figure}
\centering
\begin{lstlisting}[language={java},frame={single}]
class A {
  public void m1() {
    B b = new B();
    b.m2();    //invocation here
  }
}
class B {
  public void m2() {
    ...
  }
}
\end{lstlisting}
\caption{Example code before instrumentation}
\label{fig:before-instru}
\end{figure}

\begin{figure}
\begin{lstlisting}[language={java},frame={single}]
class A {
  public void m1() {
    ...
    b.m2();    //invocation here
    String record = RecordUtils.id(invokeExpression, b);
    RecordUtils.record(record);
  }
}
\end{lstlisting}
\caption{Example code after instrumentation}
\label{fig:after-instru}
\end{figure}



\section{Evaluation}\label{sec:evaluation}
We evaluate our approach by measuring its performance on $13$ benchmark programs...
\subsection{Efficiency}\label{subsec:efficiency}
We executed each benchmark program $10$ times with the CHA, PTA and TFA algorithms. We calculated the average time consumption...
\subsection{Precision}\label{subsec:precision}
\subsubsection{Reflection Call}\label{subsubsec:reflection-call}
\subsubsection{JNI Call}\label{subsubsec:jni-call}
\subsubsection{Library}\label{subsubsec:library}
\subsubsection{Array Approximation}\label{subsubsec:array-approximation}

\section{Related Work}\label{sec:related-work}
There are not many works focusing on general purpose call graph construction algorithms, and we give a brief review of these works first.

\section{Conclusion}\label{sec:conclusion}
In this paper we have proposed Type Flow Analysis (TFA), an algorithm that constructs call graph edges for Object-Oriented programming languages.

\label{lastpage}

\end{document}
